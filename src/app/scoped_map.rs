use std::any::TypeId;
use std::collections::HashMap;
use std::fmt;
use std::hash::{BuildHasherDefault, Hasher};
use std::marker::PhantomData;

use super::ScopeId;

/// A macro to create a `ScopedKey<T>`.
///
/// # Examples
///
/// ```
/// #[macro_use]
/// extern crate tsukuyomi;
///
/// # use tsukuyomi::App;
/// # fn main() -> tsukuyomi::AppResult<()> {
/// global_key!(static NAME: String);
///
/// let app = App::builder()
///     .set(&NAME, "Alice".into())
///     .mount("/static", |s| {
///         s.set(&NAME, "Bob".into());
///     })
///     .finish()?;
/// # Ok(())
/// # }
/// ```
#[cfg(not(feature = "nightly"))]
#[macro_export]
macro_rules! global_key {
    ($(
        $(#[$m:meta])*
        static $NAME:ident : $t:ty;
    )*) => {$(
        $(#[$m])*
        static $NAME: $crate::app::ScopedKey<$t> = {
            fn __key() -> ::std::any::TypeId {
                struct __A;
                ::std::any::TypeId::of::<__A>()
            }
            $crate::app::ScopedKey {
                __key,
                __marker: ::std::marker::PhantomData,
            }
        };
    )*};
    ($(
        $(#[$m:meta])*
        static $NAME:ident : $t:ty
    );*) => {
        global_key!($(
            $(#[$m])*
            static $NAME: $t;
        )*)
    };
}

#[cfg(feature = "nightly")]
#[macro_export]
macro_rules! global_key {
    ($(
        $(#[$m:meta])*
        $vis:vis static $NAME:ident : $t:ty;
    )*) => {$(
        $(#[$m])*
        $vis static $NAME: $crate::app::ScopedKey<$t> = {
            fn __key() -> ::std::any::TypeId {
                struct __A;
                ::std::any::TypeId::of::<__A>()
            }
            $crate::app::ScopedKey {
                __key,
                __marker: ::std::marker::PhantomData,
            }
        };
    )*};
    ($(
        $(#[$m:meta])*
        $vis:vis static $NAME:ident : $t:ty
    );*) => {
        global_key!($(
            $(#[$m])*
            $vis static $NAME: $t;
        )*)
    };
}

/// A type representing a key for scope-local data stored in a ScopedMap.
///
/// The value of this type are generated by the `global_key!` macro.
#[derive(Debug)]
pub struct ScopedKey<T> {
    // not a public API.
    #[doc(hidden)]
    pub __key: fn() -> TypeId,
    // not a public API.
    #[doc(hidden)]
    pub __marker: PhantomData<fn() -> T>,
}

// ==== ScopedValue ====

struct TypedScopedValue<T> {
    global: Option<T>,
    locals: Vec<Option<T>>,
    forward_ids: Vec<Option<ScopeId>>,
}

#[cfg_attr(tarpaulin, skip)]
impl<T> fmt::Debug for TypedScopedValue<T> {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let locals = self.locals.iter().map(|_| "<value>").collect::<Vec<_>>();
        f.debug_struct("TypedScopedValue")
            .field("global", &self.global.as_ref().map(|_| "<value>"))
            .field("locals", &locals)
            .field("forward_ids", &self.forward_ids)
            .finish()
    }
}

impl<T> TypedScopedValue<T> {
    fn new(value: T, id: ScopeId) -> TypedScopedValue<T> {
        match id {
            ScopeId::Global => Self::new_global(value),
            ScopeId::Local(pos) => Self::new_local(value, pos),
        }
    }

    fn new_global(value: T) -> TypedScopedValue<T> {
        TypedScopedValue {
            global: Some(value),
            locals: vec![],
            forward_ids: vec![],
        }
    }

    fn new_local(value: T, pos: usize) -> TypedScopedValue<T> {
        let mut locals = Vec::with_capacity(pos);
        for _ in 0..pos {
            locals.push(None);
        }
        locals.push(Some(value));

        TypedScopedValue {
            global: None,
            locals,
            forward_ids: vec![],
        }
    }

    fn get(&self, id: ScopeId) -> Option<&T> {
        match id {
            ScopeId::Global => self.global.as_ref(),
            ScopeId::Local(pos) => self.get_local(pos),
        }
    }

    fn get_local(&self, pos: usize) -> Option<&T> {
        match *self.forward_ids.get(pos)? {
            Some(ScopeId::Local(id)) => self.locals.get(id)?.as_ref(),
            _ => self.global.as_ref(),
        }
    }

    fn set(&mut self, value: T, id: ScopeId) {
        match id {
            ScopeId::Global => self.global = Some(value),
            ScopeId::Local(pos) => self.set_local(value, pos),
        }
    }

    fn set_local(&mut self, value: T, pos: usize) {
        if self.locals.get_mut(pos).map_or(false, |v| v.is_some()) {
            return;
        }

        if self.locals.len() < pos {
            let len = pos - self.locals.len();
            self.locals.reserve_exact(len);
            for _ in 0..len {
                self.locals.push(None);
            }
        }
        self.locals.push(Some(value));
    }

    fn finalize(&mut self, parents: &[ScopeId]) {
        if parents.len() > self.locals.len() {
            let additional = parents.len() - self.locals.len();
            for _ in 0..additional {
                self.locals.push(None);
            }
        }

        self.forward_ids = {
            let lookup = |mut pos: usize| -> Option<ScopeId> {
                loop {
                    if self.locals[pos].is_some() {
                        return Some(ScopeId::Local(pos));
                    }
                    pos = parents.get(pos)?.local_id()?;
                }
            };

            (0..parents.len()).map(lookup).collect()
        };
    }
}

trait ScopedValue: Send + Sync + 'static {
    fn fmt_debug(&self, f: &mut fmt::Formatter) -> fmt::Result;
    fn finalize(&mut self, parents: &[ScopeId]);
}

impl<T: Send + Sync + 'static> ScopedValue for TypedScopedValue<T> {
    fn fmt_debug(&self, f: &mut fmt::Formatter) -> fmt::Result {
        fmt::Debug::fmt(self, f)
    }

    fn finalize(&mut self, parents: &[ScopeId]) {
        self.finalize(parents);
    }
}

impl fmt::Debug for dyn ScopedValue {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        self.fmt_debug(f)
    }
}

impl dyn ScopedValue {
    #[cfg_attr(feature = "cargo-clippy", allow(cast_ptr_alignment))]
    unsafe fn downcast_ref_unchecked<T: Send + Sync + 'static>(&self) -> &TypedScopedValue<T> {
        &*(self as *const dyn ScopedValue as *const TypedScopedValue<T>)
    }

    #[cfg_attr(feature = "cargo-clippy", allow(cast_ptr_alignment))]
    unsafe fn downcast_mut_unchecked<T: Send + Sync + 'static>(&mut self) -> &mut TypedScopedValue<T> {
        &mut *(self as *mut dyn ScopedValue as *mut TypedScopedValue<T>)
    }
}

// ==== Container ====

struct IdentHash(u64);

impl Default for IdentHash {
    fn default() -> IdentHash {
        IdentHash(0)
    }
}

impl Hasher for IdentHash {
    fn finish(&self) -> u64 {
        self.0
    }

    fn write(&mut self, bytes: &[u8]) {
        for b in bytes {
            self.write_u8(*b);
        }
    }

    fn write_u8(&mut self, i: u8) {
        self.0 = (self.0 << 8) | u64::from(i);
    }

    fn write_u64(&mut self, i: u64) {
        self.0 = i;
    }
}

#[derive(Debug)]
pub(crate) struct ScopedMap {
    map: HashMap<TypeId, Box<dyn ScopedValue>, BuildHasherDefault<IdentHash>>,
}

impl ScopedMap {
    pub(crate) fn get<T>(&self, key: &'static ScopedKey<T>, id: ScopeId) -> Option<&T>
    where
        T: Send + Sync + 'static,
    {
        unsafe { self.map.get(&(key.__key)())?.downcast_ref_unchecked().get(id) }
    }
}

#[derive(Default)]
pub(super) struct Builder {
    map: HashMap<TypeId, Box<dyn ScopedValue>, BuildHasherDefault<IdentHash>>,
}

impl fmt::Debug for Builder {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        f.debug_struct("Builder").finish()
    }
}

impl Builder {
    pub(super) fn set<T>(&mut self, key: &'static ScopedKey<T>, value: T, id: ScopeId)
    where
        T: Send + Sync + 'static,
    {
        let mut value_opt = Some(value);
        self.map
            .entry((key.__key)())
            .and_modify(|v| unsafe {
                v.downcast_mut_unchecked().set(value_opt.take().unwrap(), id);
            })
            .or_insert_with(|| Box::new(TypedScopedValue::new(value_opt.take().unwrap(), id)));
    }

    pub(super) fn finish(mut self, parents: &[ScopeId]) -> ScopedMap {
        for value in self.map.values_mut() {
            value.finalize(parents);
        }

        ScopedMap { map: self.map }
    }
}
